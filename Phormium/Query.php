<?php

namespace Phormium;

/**
 * Generates and executes SQL queries.
 */
class Query
{
    /**
     * Meta data of the model which the Query will handle.
     * @var \Phormium\Meta
     */
    private $meta;

    public function __construct(Meta $meta)
    {
        $this->meta = $meta;
    }

    /**
     * Constructs and executes a SELECT query.
     *
     * @param array $filters Array of {@link Filter} instances used to form
     *      the WHERE clause.
     * @param array $order Array of strings used to form the ORDER BY clause.
     * @param string $fetchType One of DB::FETCH_* constants.
     *
     * @return array An array of {@link Model} instances corresponing to given
     *      criteria.
     */
    public function select($filters, $order, $fetchType)
    {
        $columns = implode(", ", $this->meta->columns);
        $table = $this->meta->table;
        $class = $this->meta->class;

        list($where, $args) = $this->constructWhere($filters);
        $order = $this->constructOrder($order);

        $sql = "SELECT {$columns} FROM {$table}{$where}{$order};";
        $conn = DB::getConnection($this->meta->database);
        return $conn->execute($sql, $args, $fetchType, $class);
    }

    /**
     * Constructs and executes a SELECT COUNT(*) query.
     *
     * @param array $filters Array of {@link Filter} instances used to form
     *      the WHERE clause.
     *
     * @return integer Number of records which match the given filter.
     */
    public function count($filters)
    {
        $table = $this->meta->table;
        list($where, $args) = $this->constructWhere($filters);

        $sql = "SELECT COUNT(*) AS count FROM {$table}{$where};";
        $conn = DB::getConnection($this->meta->database);
        $data = $conn->execute($sql, $args, DB::FETCH_ARRAY);
        return (integer) $data[0]['count'];
    }

    /**
     * Constructs and executes a SELECT aggregate query.
     *
     * @param array $filters Array of {@link Filter} instances used to form
     *      the WHERE clause.
     * @param Aggregate $aggregate The aggregate to perform.
     * @return string Result of the aggregate query.
     */
    public function aggregate($filters, $aggregate)
    {
        $table = $this->meta->table;
        $type = $aggregate->type;

        $column = $aggregate->column;
        if (!in_array($column, $this->meta->columns)) {
            throw new \Exception("Error forming aggregate query. Column [$column] does not exist in table [$table].");
        }

        list($where, $args) = $this->constructWhere($filters);
        $select = $aggregate->render();

        $sql = "SELECT {$select} as aggregate FROM {$table}{$where};";
        $conn = DB::getConnection($this->meta->database);
        $data = $conn->execute($sql, $args, DB::FETCH_ARRAY);
        return $data[0]['aggregate'];
    }

    /**
     * Constructs and executes an INSERT statement for a single Model instance.
     */
    public function insert(Model $model)
    {
        $meta = $this->meta;

        // Determine whether to allow PK to be generated by the database. Conditions:
        // 1. Only single-column primary keys
        //    TODO: consider if this should be considered for composite keys
        // 2. The pk column must not be populated
        $pkAutogen = false;
        if (count($meta->pk) === 1) {
            $pkColumn = $meta->pk[0];
            if (!isset($model->{$pkColumn})) {
                $pkAutogen = true;
            }
        }

        // If PK is auto-generated, exclude it from the insert query
        $columns = $pkAutogen ? $meta->nonPK : $meta->columns;

        // If PK is not auto-generated, make sure all PK columns are populated
        // TODO: Maybe this is not necessary?
        if (!$pkAutogen) {
            foreach ($meta->pk as $column) {
                if (!isset($model->{$column})) {
                    throw new \Exception("Cannot insert. Primary key column(s) not set.");
                }
            }
        }

        // Collect query arguments
        $args = array();
        foreach ($columns as $column) {
            $args[] = $model->{$column};
        }

        // Construct the query
        $query = "INSERT INTO {$meta->table} (";
        $query .= implode(', ', $columns);
        $query .= ") VALUES (";
        $query .= implode(', ', array_fill(0, count($columns), '?'));
        $query .= ");";

        $conn = DB::getConnection($meta->database);
        $conn->executeNoFetch($query, $args);

        // If PK is auto-generated, populate it
        if ($pkAutogen) {
            $pkColumn = $meta->pk[0];
            $model->{$pkColumn} = $conn->getLastInsertID();
        }
    }

    /**
     * Constructs and executes an UPDATE statement for a single Model instance.
     */
    public function update(Model $model)
    {
        $meta = $this->meta;

        // All pk fields must be set to attempt an update
        foreach ($meta->pk as $column) {
            if (!isset($model->{$column})) {
                throw new \Exception("Cannot update model because primary key column [$pk] is not set.");
            }
        }

        // Collect query arguments (primary key goes last, skip it here)
        $args = array();
        $updates = array();
        foreach ($meta->nonPK as $column) {
            $updates[] = "$column = ?";
            $args[] = $model->{$column};
        }

        // Add primary key to where and arguments
        $where = array();
        foreach ($meta->pk as $column) {
            $where[] = "{$column} = ?";
            $args[] = $model->$column;
        }

        // Construct the query
        $query  = "UPDATE {$meta->table} SET ";
        $query .= implode(', ', $updates);
        $query .= " WHERE ";
        $query .= implode(' AND ', $where);

        $conn = DB::getConnection($meta->database);
        $conn->executeNoFetch($query, $args);
        return $conn->getLastRowCount();
    }

    /**
     * Deletes a single model from the database.
     */
    public function delete(Model $model)
    {
        $pk = $model->getPK();

        // Construct where clause based on primary key
        $args = array();
        $where = array();
        foreach ($pk as $column => $value) {

            // All PK fields must be set
            if (!isset($value)) {
                throw new \Exception("Cannot delete. Primary key column [$key] is not set.");
            }

            $where[] = "{$column} = ?";
            $args[] = $value;
        }
        $where = implode(' AND ', $where);

        $query = "DELETE FROM {$this->meta->table} WHERE {$where}";
        $conn = DB::getConnection($this->meta->database);
        $conn->executeNoFetch($query, $args);
        return $conn->getLastRowCount();
    }

    /**
     * Constructs and executes an UPDATE statement for all records matching
     * the given filters.
     */
    public function batchUpdate($filters, $updates)
    {
        $updateBits = array();

        // Check columns exist
        foreach ($updates as $column => $value) {
            if (!in_array($column, $this->meta->columns)) {
                throw new \Exception("Column [$column] does not exist in table [{$this->meta->table}].");
            }

            $updateBits[] = "{$column} = ?";
        }

        list($where, $args) = $this->constructWhere($filters);
        $args = array_merge(array_values($updates), $args);

        $query  = "UPDATE {$this->meta->table} ";
        $query .= "SET " . implode(', ', $updateBits);
        $query .= $where;

        $conn = DB::getConnection($this->meta->database);
        $conn->executeNoFetch($query, $args);
        return $conn->getLastRowCount();
    }

    /**
     * Constructs and executes a DELETE statement for all records matching
     * the given filters.
     */
    public function batchDelete($filters)
    {
        list($where, $args) = $this->constructWhere($filters);

        $query = "DELETE FROM {$this->meta->table}{$where}";

        $conn = DB::getConnection($this->meta->database);
        $conn->executeNoFetch($query, $args);
        return $conn->getLastRowCount();
    }

    // ******************************************
    // *** Private methods                    ***
    // ******************************************

    /** Constructs a WHERE clause for given filters. */
    private function constructWhere($filters)
    {
        if (empty($filters)) {
            return array("", array());
        }

        // Accumulate the where clauses and arguments from each filter
        $where = array();
        $args = array();
        foreach ($filters as $filter) {
            list($w, $a) = $filter->render($this->meta);
            $where[] = $w;
            $args = array_merge($args, $a);
        }
        $where = " WHERE " . implode(" AND ", $where);
        return array($where, $args);
    }

    /** Constructs an ORDER BY clause. */
    private function constructOrder($order)
    {
        if (empty($order)) {
            return "";
        }
        return " ORDER BY " . implode(', ', $order);
    }
}
